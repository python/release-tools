parameters:
  Include: '*'
  Exclude: ''
  Filter: ''
  WorkingDir: '$(Build.BinariesDirectory)'
  ExtractDir: ''
  SigningCertificate: ''
  ExportCommand: ''
  ContinueOnError: false
  AzureServiceConnectionName: 'Python Signing'

steps:
- ${{ if parameters.SigningCertificate }}:
  - powershell: |
      # Install test root, so that signing tool can do test signing
      # See https://github.com/dotnet/sign/issues/908 for underlying issue
      Import-Certificate -FilePath .\TestCertRoot.cer -CertStoreLocation Cert:\LocalMachine\Root

      # Install sign tool
      dotnet tool install --global --prerelease sign
      $signtool = (gcm sign -EA SilentlyContinue).Source
      if (-not $signtool) {
        $signtool = (gi "${env:USERPROFILE}\.dotnet\tools\sign.exe").FullName
      }
      $signargs = 'code trusted-signing -v Information ' + `
        '-fd sha256 -t http://timestamp.acs.microsoft.com -td sha256 ' + `
        '-tse "$(TrustedSigningUri)" -tsa "$(TrustedSigningAccount)" -tscp "$(TrustedSigningCertificateName)" ' + `
        '-d "$(SigningDescription)" '

      Write-Host "##vso[task.setvariable variable=__TrustedSigningCmd]$signtool"
      Write-Host "##vso[task.setvariable variable=__TrustedSigningArgs]$signargs"
      if ($env:EXPORT_COMMAND) {
        $signcmd = """$signtool"" $signargs"
        Write-Host "##vso[task.setvariable variable=${env:EXPORT_COMMAND}]$signcmd"
      }
    workingDirectory: $(Build.BinariesDirectory)
    displayName: 'Install Trusted Signing tools'
    env:
      EXPORT_COMMAND: ${{ parameters.ExportCommand }}

  # We sign in once with the AzureCLI task, as it uses OIDC to obtain a
  # temporary token. But the task also logs out, and so we save the token and
  # use it to log in persistently (for the rest of the build).
  - task: AzureCLI@2
    displayName: 'Authenticate signing tools (1/2)'
    inputs:
      azureSubscription: ${{ parameters.AzureServiceConnectionName }}
      scriptType: 'ps'
      scriptLocation: 'inlineScript'
      inlineScript: |
        "##vso[task.setvariable variable=AZURE_CLIENT_ID;issecret=true]${env:servicePrincipalId}" 
        "##vso[task.setvariable variable=AZURE_ID_TOKEN;issecret=true]${env:idToken}"
        "##vso[task.setvariable variable=AZURE_TENANT_ID;issecret=true]${env:tenantId}"
      addSpnToEnvironment: true

  - powershell: >
      az login --service-principal
      -u $(AZURE_CLIENT_ID)
      --tenant $(AZURE_TENANT_ID)
      --allow-no-subscriptions
      --federated-token $(AZURE_ID_TOKEN)
    displayName: 'Authenticate signing tools (2/2)'

  - ${{ if parameters.Include }}:
    - powershell: |
        if ("${{ parameters.Exclude }}") {
          $files = (dir ${{ parameters.Include }} -Exclude ${{ parameters.Exclude }} -File)
        } else {
          $files = (dir ${{ parameters.Include }} -File)
        }
        if ($env:FILTER) {
          ($env:FILTER -split ';') -join "`n" | Out-File __filelist.txt -Encoding utf8
        } else {
          "*" | Out-File __filelist.txt -Encoding utf8
        }
        foreach ($f in $files) {
          & $env:TRUSTED_SIGNING_CMD @(-split $env:TRUSTED_SIGNING_ARGS) -fl __filelist.txt $f
          if (-not $?) { exit $LASTEXITCODE }
        }
        del __filelist.txt
      displayName: 'Sign binaries'
      ${{ if eq(parameters.ContinueOnError, 'false') }}:
        retryCountOnTaskFailure: 3
      ${{ else }}:
        continueOnError: true
      workingDirectory: ${{ parameters.WorkingDir }}
      env:
        TRUSTED_SIGNING_CMD: $(__TrustedSigningCmd)
        TRUSTED_SIGNING_ARGS: $(__TrustedSigningArgs)
        ${{ if parameters.Filter }}:
          FILTER: ${{ parameters.Filter }}


- ${{ if parameters.ExtractDir }}:
  - powershell: |
      if ("${{ parameters.Exclude }}") {
        $files = (dir ${{ parameters.Include }} -Exclude ${{ parameters.Exclude }} -File)
      } else {
        $files = (dir ${{ parameters.Include }} -File)
      }
      $c = $files | %{ (Get-AuthenticodeSignature $_).SignerCertificate } | ?{ $_ -ne $null } | select -First 1
      if (-not $c) {
        Write-Host "Failed to find certificate for ${{ parameters.SigningCertificate }}"
        exit
      }

      $d = mkdir "${{ parameters.ExtractDir }}" -Force
      $cf = "$d\cert.cer"
      [IO.File]::WriteAllBytes($cf, $c.RawData)
      $csha = (Get-FileHash $cf -Algorithm SHA256).Hash.ToLower()

      $info = @{ Subject=$c.Subject; SHA256=$csha; }
      $info | ConvertTo-JSON -Compress | Out-File -Encoding utf8 "$d\certinfo.json"
    displayName: "Extract certificate info"
    workingDirectory: ${{ parameters.WorkingDir }}
